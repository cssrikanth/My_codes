!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.9 (r5096) - 24 Feb 2014 16:53
!
!  Differentiation of main in forward (tangent) mode (with options i4 dr8 r4):
!   variations   of useful results: alloc(*k) alloc(*temp) alloc(*oldt)
!                alloc(*t)
!   with respect to varying inputs: alloc(*k) alloc(*temp) alloc(*oldt)
!                alloc(*t)
!   RW status of diff variables: alloc(*k):in-out alloc(*temp):in-out
!                alloc(*oldt):in-out alloc(*t):in-out
PROGRAM MAIN_D
  USE DIFFSIZES
!  Hint: ISIZE1OFabs should be the size of dimension 1 of array abs
!  Hint: ISIZE2OFabs should be the size of dimension 2 of array abs
  IMPLICIT NONE
  INTEGER :: n, ncount, i, j
  REAL :: dx, error, tol, lent, pertub
!      real,allocatable,intent(in),dimension(:,:)::k
  REAL :: func
  REAL, DIMENSION(:, :), ALLOCATABLE :: t, x, y, oldt, temp, k
  REAL, DIMENSION(:, :), ALLOCATABLE :: td, oldtd, tempd, kd
  INTRINSIC SUM
  INTRINSIC ABS
  REAL :: abs0(ISIZE1OFabs, ISIZE2OFabs)
!grid details
  n = 100
  ALLOCATE(td(n, n))
  td = 0.0
  ALLOCATE(t(n, n))
  ALLOCATE(oldtd(n, n))
  oldtd = 0.0
  ALLOCATE(oldt(n, n))
  ALLOCATE(tempd(n, n))
  tempd = 0.0
  ALLOCATE(temp(n, n))
  ALLOCATE(kd(n, n))
  kd = 0.0
  ALLOCATE(k(n, n))
!solution details
  error = 0.0
  tol = 1e-8
  ncount = 0
  pertub = 0
!initial guess and bc
  DO i=1,n
    DO j=1,n
      IF (i .EQ. 0) THEN
        td(i, j) = 0.0
        t(i, j) = 10
        kd(i, j) = 0.0
        k(i, j) = 10 + pertub
      ELSE IF (j .EQ. 0) THEN
        td(i, j) = 0.0
        t(i, j) = 20
        kd(i, j) = 0.0
        k(i, j) = 5 + pertub
      ELSE IF (i .EQ. n) THEN
        td(i, j) = 0.0
        t(i, j) = 20
        kd(i, j) = 0.0
        k(i, j) = 1 + pertub
      ELSE IF (j .EQ. n) THEN
        td(i, j) = 0.0
        t(i, j) = 40
        kd(i, j) = 0.0
        k(i, j) = 50 + pertub
      ELSE
        td(i, j) = 0.0
        t(i, j) = 0.0
        kd(i, j) = 0.0
        k(i, j) = 60 + pertub
      END IF
    END DO
  END DO
!solver
  DO 
    oldtd = td
    oldt = t
    DO i=2,n-1
      DO j=2,n-1
        td(i, j) = ((td(i+1, j)*k(i+1, j)+t(i+1, j)*kd(i+1, j)+td(i-1, j&
&         )*k(i-1, j)+t(i-1, j)*kd(i-1, j)+td(i, j+1)*k(i, j+1)+t(i, j+1&
&         )*kd(i, j+1)+td(i, j-1)*k(i, j-1)+t(i, j-1)*kd(i, j-1))*(k(i+1&
&         , j)+k(i-1, j)+k(i, j+1)+k(i, j-1))-(t(i+1, j)*k(i+1, j)+t(i-1&
&         , j)*k(i-1, j)+t(i, j+1)*k(i, j+1)+t(i, j-1)*k(i, j-1))*(kd(i+&
&         1, j)+kd(i-1, j)+kd(i, j+1)+kd(i, j-1)))/(k(i+1, j)+k(i-1, j)+&
&         k(i, j+1)+k(i, j-1))**2
        t(i, j) = (t(i+1, j)*k(i+1, j)+t(i-1, j)*k(i-1, j)+t(i, j+1)*k(i&
&         , j+1)+t(i, j-1)*k(i, j-1))/(k(i+1, j)+k(i-1, j)+k(i, j+1)+k(i&
&         , j-1))
      END DO
    END DO
!objective func
    func = SUM(t)
!     call solver(t,k,n)
    DO i=2,n-1
      DO j=2,n-1
        IF (t(i, j) - oldt(i, j) .GE. 0.) THEN
          tempd(i, j) = td(i, j) - oldtd(i, j)
          temp(i, j) = t(i, j) - oldt(i, j)
        ELSE
          tempd(i, j) = -(td(i, j)-oldtd(i, j))
          temp(i, j) = -(t(i, j)-oldt(i, j))
        END IF
      END DO
    END DO
    WHERE (t .GE. 0.0) 
      abs0 = t
    ELSEWHERE
      abs0 = -t
    END WHERE
    error = SUM(temp)/SUM(abs0)
    PRINT*, error
    IF (error .LT. tol) THEN
      GOTO 100
    ELSE
      ncount = ncount + 1
    END IF
  END DO
 100 PRINT*, 'solution converged with residual:', error, 'after', ncount&
&    , 'iterations'
END PROGRAM MAIN_D
